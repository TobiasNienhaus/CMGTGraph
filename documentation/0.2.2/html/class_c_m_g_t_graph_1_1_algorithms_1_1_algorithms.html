<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CMGTGraph: CMGTGraph.Algorithms.Algorithms Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_very_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CMGTGraph
   &#160;<span id="projectnumber">0.2.2</span>
   </div>
   <div id="projectbrief">Yet another graph library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CMGTGraph.Algorithms.Algorithms Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html" title="A basic node that links an entry in a node with a predecessor.">Node</a> specifically built for the purposes of the A* algorithm. It saves the current data it represents (the thing from the graph), the predecessor of this node in the current run of the algorithm, the accumulated path length to this node currently, the estimated distance from this node to the finish and an option to get the estimated complete path length going through this node.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node specifically tailored to the dijkstra algorithm with a predecessor and information about the current path length to this node.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic node that links an entry in a node with a predecessor.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result.html">PathFindingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing data about the path-finding query.  <a href="struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3719d88e07c2d9cab0674028f3fdfa06"><td class="memItemLeft" align="right" valign="top">static List&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a3719d88e07c2d9cab0674028f3fdfa06">AStarSolve&lt; T &gt;</a> (this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; graph, T start, T end, <a class="el" href="interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator.html">ICalculator</a>&lt; T &gt; calculator=null)</td></tr>
<tr class="memdesc:a3719d88e07c2d9cab0674028f3fdfa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a path between two points in the graph using the A* algorithm. If no path can be found, an empty list is returned.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a3719d88e07c2d9cab0674028f3fdfa06">More...</a><br /></td></tr>
<tr class="separator:a3719d88e07c2d9cab0674028f3fdfa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6850e8e292b5b81d93d85978c633e96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result.html">PathFindingResult</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#ac6850e8e292b5b81d93d85978c633e96">AStarSolveWithInfo&lt; T &gt;</a> (this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; g, T start, T end, <a class="el" href="interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator.html">ICalculator</a>&lt; T &gt; calculator=null)</td></tr>
<tr class="memdesc:ac6850e8e292b5b81d93d85978c633e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a path between two points in the graph using the A* algorithm. A list of the visited nodes is also returned. If no path can be found, the PathFindingResult&lt;T&gt; will be empty, but no members will be null. <br  />
PathFindingResult&lt;T&gt; will contain the found path, the nodes that were queued to be evaluated (in PathFindingResult&lt;T&gt;.OpenNodes) and the nodes that were finally evaluated (in PathFindingResult&lt;T&gt;.ClosedNodes)  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#ac6850e8e292b5b81d93d85978c633e96">More...</a><br /></td></tr>
<tr class="separator:ac6850e8e292b5b81d93d85978c633e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd10463f4a8e867ac293ceffb169f60"><td class="memItemLeft" align="right" valign="top"><a id="afcd10463f4a8e867ac293ceffb169f60"></a>
static List&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DijkstraSolve&lt; T &gt;</b> (this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; graph, T start, T end)</td></tr>
<tr class="separator:afcd10463f4a8e867ac293ceffb169f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb23b5d31c817edaeec719691a89422"><td class="memItemLeft" align="right" valign="top"><a id="abdb23b5d31c817edaeec719691a89422"></a>
static <a class="el" href="struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result.html">PathFindingResult</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DijkstraSolveWithInfo&lt; T &gt;</b> (this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; g, T start, T end)</td></tr>
<tr class="separator:abdb23b5d31c817edaeec719691a89422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ca1e185f6b7b197319633e5704ff0f"><td class="memItemLeft" align="right" valign="top">static List&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#ad6ca1e185f6b7b197319633e5704ff0f">IterativeBfsSolve&lt; T &gt;</a> (this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; graph, T start, T end)</td></tr>
<tr class="memdesc:ad6ca1e185f6b7b197319633e5704ff0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the iterative bfs algorithm to find a path between <em>start</em>  and <em>end</em> .  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#ad6ca1e185f6b7b197319633e5704ff0f">More...</a><br /></td></tr>
<tr class="separator:ad6ca1e185f6b7b197319633e5704ff0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5337626a09f0ead8553600d50ecfce2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result.html">PathFindingResult</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#ac5337626a09f0ead8553600d50ecfce2">IterativeBfsSolveWithInfo&lt; T &gt;</a> (this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; graph, T start, T end)</td></tr>
<tr class="memdesc:ac5337626a09f0ead8553600d50ecfce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use iterative BFS to find a path between <em>start</em>  and <em>end</em> . This method will also return the visited nodes in the process. <br  />
The returned PathFindingResult&lt;T&gt; will contain the path (in PathFindingResult&lt;T&gt;.Path), and the visited nodes (in PathFindingResult&lt;T&gt;.OpenNodes). PathFindingResult&lt;T&gt;.ClosedNodes will be empty as that is not applicable here.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#ac5337626a09f0ead8553600d50ecfce2">More...</a><br /></td></tr>
<tr class="separator:ac5337626a09f0ead8553600d50ecfce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1d3fb0d8a4115a811794b761e09f8c"><td class="memItemLeft" align="right" valign="top">static List&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a6e1d3fb0d8a4115a811794b761e09f8c">RecursiveSolve&lt; T &gt;</a> (this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; graph, T start, T end)</td></tr>
<tr class="memdesc:a6e1d3fb0d8a4115a811794b761e09f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kind of the worst kind of pathfinding you can choose, ever. <br  />
It will (eventually) return a path between start and end using a recursive algorithm.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a6e1d3fb0d8a4115a811794b761e09f8c">More...</a><br /></td></tr>
<tr class="separator:a6e1d3fb0d8a4115a811794b761e09f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aa6ef850657425957da22c35dd288c3e5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#aa6ef850657425957da22c35dd288c3e5">AStarGetMostPromisingNode&lt; T &gt;</a> (HashSet&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a>&lt; T &gt;&gt; open)</td></tr>
<tr class="memdesc:aa6ef850657425957da22c35dd288c3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the most promising node from the provided open list. It will search for the node with the lowest F value (<a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html#a287d611297fcd9a4f9ede4b018ecbe21" title="The estimated complete path length that would go through this node. It is the length to this node (Di...">AStarNode&lt;T&gt;.EstimatedCompletePathLength</a>)  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#aa6ef850657425957da22c35dd288c3e5">More...</a><br /></td></tr>
<tr class="separator:aa6ef850657425957da22c35dd288c3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c58d3551358817dae374f53dfd9cc2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a92c58d3551358817dae374f53dfd9cc2">AStarExpandNode&lt; T &gt;</a> (<a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a>&lt; T &gt; node, T finish, IEnumerable&lt; T &gt; neighbors, ICollection&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a>&lt; T &gt;&gt; open, ICollection&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a>&lt; T &gt;&gt; closed, <a class="el" href="interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator.html">ICalculator</a>&lt; T &gt; calculator)</td></tr>
<tr class="memdesc:a92c58d3551358817dae374f53dfd9cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a node, which means add all the neighbors to the open list, initialize them with the correct values (if that hasn't been done) and update them if necessary (a better path to them is found)  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a92c58d3551358817dae374f53dfd9cc2">More...</a><br /></td></tr>
<tr class="separator:a92c58d3551358817dae374f53dfd9cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa659843ef4c92031c5d2da97b63b2a1a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#aa659843ef4c92031c5d2da97b63b2a1a">DijkstraExpandNode&lt; T &gt;</a> (<a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a>&lt; T &gt; node, HashSet&lt; T &gt; neighbors, ICollection&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a>&lt; T &gt;&gt; open, ICollection&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a>&lt; T &gt;&gt; closed, <a class="el" href="interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator.html">ICalculator</a>&lt; T &gt; calculator)</td></tr>
<tr class="memdesc:aa659843ef4c92031c5d2da97b63b2a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a node, which basically means to check if any of the neighbors need their values changed (or initialized) and, if they aren't already, the eligible neighbors will be added to the waiting list, waiting to be evaluated.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#aa659843ef4c92031c5d2da97b63b2a1a">More...</a><br /></td></tr>
<tr class="separator:aa659843ef4c92031c5d2da97b63b2a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90995367a09dc1b1fabed2dcf69a0bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#aa90995367a09dc1b1fabed2dcf69a0bd">ThrowOnInvalidInput&lt; T &gt;</a> (this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; g, T start, T end)</td></tr>
<tr class="memdesc:aa90995367a09dc1b1fabed2dcf69a0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw if one of the input parameters is not a valid start node.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#aa90995367a09dc1b1fabed2dcf69a0bd">More...</a><br /></td></tr>
<tr class="separator:aa90995367a09dc1b1fabed2dcf69a0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62ecdf8f72844e361b2a623215fb276"><td class="memItemLeft" align="right" valign="top">static List&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#ad62ecdf8f72844e361b2a623215fb276">BuildPath&lt; T &gt;</a> (<a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a>&lt; T &gt; from, IEnumerable&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a>&lt; T &gt;&gt; knownNodes)</td></tr>
<tr class="separator:ad62ecdf8f72844e361b2a623215fb276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf6ae8891261175c39e7ef8293b5783"><td class="memItemLeft" align="right" valign="top">static List&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a2cf6ae8891261175c39e7ef8293b5783">BuildRecursiveReversePath&lt; T &gt;</a> (<a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a>&lt; T &gt; from, IReadOnlyDictionary&lt; T, <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a>&lt; T &gt;&gt; knownNodes)</td></tr>
<tr class="memdesc:a2cf6ae8891261175c39e7ef8293b5783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively build a path from a node using a lookup of values from the node wrapper to the actual containing type.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a2cf6ae8891261175c39e7ef8293b5783">More...</a><br /></td></tr>
<tr class="separator:a2cf6ae8891261175c39e7ef8293b5783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d5da12d0957916d595a38770329d5f"><td class="memItemLeft" align="right" valign="top">static List&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a07d5da12d0957916d595a38770329d5f">RecursiveSolve&lt; T &gt;</a> (<a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt; graph, T start, T end, List&lt; T &gt; pathTo, int depth=0)</td></tr>
<tr class="memdesc:a07d5da12d0957916d595a38770329d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual recursive method that is used to calculate the path. <br  />
This method has an "artificial" recursion anchor at MaxDepth to prevent a StackOverflowException. It will simply stop recursing deeper after a depth higher than MaxDepth. <br  />
Use cautiously :) it can take a while.  <a href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html#a07d5da12d0957916d595a38770329d5f">More...</a><br /></td></tr>
<tr class="separator:a07d5da12d0957916d595a38770329d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a5d0d0fa3bb2d2c6203af17dd61eba219"><td class="memItemLeft" align="right" valign="top"><a id="a5d0d0fa3bb2d2c6203af17dd61eba219"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxDepth</b> = 100</td></tr>
<tr class="separator:a5d0d0fa3bb2d2c6203af17dd61eba219"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a92c58d3551358817dae374f53dfd9cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c58d3551358817dae374f53dfd9cc2">&#9670;&nbsp;</a></span>AStarExpandNode&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CMGTGraph.Algorithms.Algorithms.AStarExpandNode&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>finish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICollection&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICollection&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator.html">ICalculator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>calculator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand a node, which means add all the neighbors to the open list, initialize them with the correct values (if that hasn't been done) and update them if necessary (a better path to them is found) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to expand</td></tr>
    <tr><td class="paramname">finish</td><td>The finish we strive for</td></tr>
    <tr><td class="paramname">neighbors</td><td>The neighbors of the passed node (to prevent passing the graph)</td></tr>
    <tr><td class="paramname">open</td><td>The list of nodes that might be expanded later</td></tr>
    <tr><td class="paramname">closed</td><td>The list of nodes we don't want to expand later</td></tr>
    <tr><td class="paramname">calculator</td><td>The calculator we want to use to calculate distances between nodes</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa6ef850657425957da22c35dd288c3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ef850657425957da22c35dd288c3e5">&#9670;&nbsp;</a></span>AStarGetMostPromisingNode&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a>&lt;T&gt; CMGTGraph.Algorithms.Algorithms.AStarGetMostPromisingNode&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">HashSet&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html">AStarNode</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>open</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the most promising node from the provided open list. It will search for the node with the lowest F value (<a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node.html#a287d611297fcd9a4f9ede4b018ecbe21" title="The estimated complete path length that would go through this node. It is the length to this node (Di...">AStarNode&lt;T&gt;.EstimatedCompletePathLength</a>) </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a3719d88e07c2d9cab0674028f3fdfa06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3719d88e07c2d9cab0674028f3fdfa06">&#9670;&nbsp;</a></span>AStarSolve&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;T&gt; CMGTGraph.Algorithms.Algorithms.AStarSolve&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator.html">ICalculator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>calculator</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a path between two points in the graph using the A* algorithm. If no path can be found, an empty list is returned. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ac6850e8e292b5b81d93d85978c633e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6850e8e292b5b81d93d85978c633e96">&#9670;&nbsp;</a></span>AStarSolveWithInfo&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result.html">PathFindingResult</a>&lt;T&gt; CMGTGraph.Algorithms.Algorithms.AStarSolveWithInfo&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator.html">ICalculator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>calculator</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a path between two points in the graph using the A* algorithm. A list of the visited nodes is also returned. If no path can be found, the PathFindingResult&lt;T&gt; will be empty, but no members will be null. <br  />
PathFindingResult&lt;T&gt; will contain the found path, the nodes that were queued to be evaluated (in PathFindingResult&lt;T&gt;.OpenNodes) and the nodes that were finally evaluated (in PathFindingResult&lt;T&gt;.ClosedNodes) </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ad62ecdf8f72844e361b2a623215fb276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62ecdf8f72844e361b2a623215fb276">&#9670;&nbsp;</a></span>BuildPath&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;T&gt; CMGTGraph.Algorithms.Algorithms.BuildPath&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>knownNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Build a path from a node (usually the finish node of the pathfinding request) and a collection of known nodes (which will be used as a look up into the graph). </p>
<p><em>from</em>  will be the last node in the built path, as this is the node to get the predecessor from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The node to build the recursively build the path from.</td></tr>
    <tr><td class="paramname">knownNodes</td><td></td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a2cf6ae8891261175c39e7ef8293b5783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf6ae8891261175c39e7ef8293b5783">&#9670;&nbsp;</a></span>BuildRecursiveReversePath&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;T&gt; CMGTGraph.Algorithms.Algorithms.BuildRecursiveReversePath&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IReadOnlyDictionary&lt; T, <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node.html">Node</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>knownNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively build a path from a node using a lookup of values from the node wrapper to the actual containing type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The node to build from</td></tr>
    <tr><td class="paramname">knownNodes</td><td>A look up from the node wrapper to the graph type</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa659843ef4c92031c5d2da97b63b2a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa659843ef4c92031c5d2da97b63b2a1a">&#9670;&nbsp;</a></span>DijkstraExpandNode&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CMGTGraph.Algorithms.Algorithms.DijkstraExpandNode&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashSet&lt; T &gt;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICollection&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICollection&lt; <a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node.html">DijkstraNode</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator.html">ICalculator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>calculator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand a node, which basically means to check if any of the neighbors need their values changed (or initialized) and, if they aren't already, the eligible neighbors will be added to the waiting list, waiting to be evaluated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to check the neighbors of</td></tr>
    <tr><td class="paramname">neighbors</td><td>The neighbors of this node</td></tr>
    <tr><td class="paramname">open</td><td>The list of nodes that are already queued for evaluation</td></tr>
    <tr><td class="paramname">closed</td><td>The list of nodes that is finished with this shit</td></tr>
    <tr><td class="paramname">calculator</td><td>The calculator to use for distance calculation</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ad6ca1e185f6b7b197319633e5704ff0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ca1e185f6b7b197319633e5704ff0f">&#9670;&nbsp;</a></span>IterativeBfsSolve&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;T&gt; CMGTGraph.Algorithms.Algorithms.IterativeBfsSolve&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the iterative bfs algorithm to find a path between <em>start</em>  and <em>end</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to solve on</td></tr>
    <tr><td class="paramname">start</td><td>The start node</td></tr>
    <tr><td class="paramname">end</td><td>The end node</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Graph&lt;T&gt;.NodeNotFoundException</td><td>This will be thrown if either start or end are in the graph.</td></tr>
    <tr><td class="paramname">InvalidOperationException</td><td>This will be thrown when one of the nodes is not passable at the time of asking (politely of course)</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ac5337626a09f0ead8553600d50ecfce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5337626a09f0ead8553600d50ecfce2">&#9670;&nbsp;</a></span>IterativeBfsSolveWithInfo&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result.html">PathFindingResult</a>&lt;T&gt; CMGTGraph.Algorithms.Algorithms.IterativeBfsSolveWithInfo&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use iterative BFS to find a path between <em>start</em>  and <em>end</em> . This method will also return the visited nodes in the process. <br  />
The returned PathFindingResult&lt;T&gt; will contain the path (in PathFindingResult&lt;T&gt;.Path), and the visited nodes (in PathFindingResult&lt;T&gt;.OpenNodes). PathFindingResult&lt;T&gt;.ClosedNodes will be empty as that is not applicable here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to operate on</td></tr>
    <tr><td class="paramname">start</td><td>The node to start searching from</td></tr>
    <tr><td class="paramname">end</td><td>The node that is the finish</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a07d5da12d0957916d595a38770329d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d5da12d0957916d595a38770329d5f">&#9670;&nbsp;</a></span>RecursiveSolve&lt; T &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;T&gt; CMGTGraph.Algorithms.Algorithms.RecursiveSolve&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; T &gt;&#160;</td>
          <td class="paramname"><em>pathTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual recursive method that is used to calculate the path. <br  />
This method has an "artificial" recursion anchor at MaxDepth to prevent a StackOverflowException. It will simply stop recursing deeper after a depth higher than MaxDepth. <br  />
Use cautiously :) it can take a while. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to perform the operation on.</td></tr>
    <tr><td class="paramname">start</td><td>The start node of the problem</td></tr>
    <tr><td class="paramname">end</td><td>The end node.</td></tr>
    <tr><td class="paramname">pathTo</td><td>The current path to the start node.</td></tr>
    <tr><td class="paramname">depth</td><td>The current depth we are at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the reverse path from start to end</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a6e1d3fb0d8a4115a811794b761e09f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1d3fb0d8a4115a811794b761e09f8c">&#9670;&nbsp;</a></span>RecursiveSolve&lt; T &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;T&gt; CMGTGraph.Algorithms.Algorithms.RecursiveSolve&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kind of the worst kind of pathfinding you can choose, ever. <br  />
It will (eventually) return a path between start and end using a recursive algorithm. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa90995367a09dc1b1fabed2dcf69a0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90995367a09dc1b1fabed2dcf69a0bd">&#9670;&nbsp;</a></span>ThrowOnInvalidInput&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CMGTGraph.Algorithms.Algorithms.ThrowOnInvalidInput&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_c_m_g_t_graph_1_1_i_read_only_graph.html">IReadOnlyGraph</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw if one of the input parameters is not a valid start node. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Graph&lt;T&gt;.NodeNotFoundException</td><td></td></tr>
    <tr><td class="paramname">InvalidOperationException</td><td></td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IEquatable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>CMGTGraph/Algorithms/Algorithms-AStar.cs</li>
<li>CMGTGraph/Algorithms/Algorithms-RecursivePath.cs</li>
<li>CMGTGraph/Algorithms/Algorithms-Dijkstra.cs</li>
<li>CMGTGraph/Algorithms/Algorithms-Helpers.cs</li>
<li>CMGTGraph/Algorithms/Algorithms-IterativeBFS.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_c_m_g_t_graph.html">CMGTGraph</a></li><li class="navelem"><a class="el" href="namespace_c_m_g_t_graph_1_1_algorithms.html">Algorithms</a></li><li class="navelem"><a class="el" href="class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms.html">Algorithms</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
