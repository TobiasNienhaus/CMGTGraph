\hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms}{}\doxysection{C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms Class Reference}
\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms}\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}
\begin{DoxyCompactList}\small\item\em A \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}} specifically built for the purposes of the A$\ast$ algorithm. It saves the current data it represents (the thing from the graph), the predecessor of this node in the current run of the algorithm, the accumulated path length to this node currently, the estimated distance from this node to the finish and an option to get the estimated complete path length going through this node. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}
\begin{DoxyCompactList}\small\item\em A node specifically tailored to the dijkstra algorithm with a predecessor and information about the current path length to this node. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}
\begin{DoxyCompactList}\small\item\em A basic node that links an entry in a node with a predecessor. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result}{Path\+Finding\+Result}}
\begin{DoxyCompactList}\small\item\em A struct containing data about the path-\/finding query. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static List$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a3719d88e07c2d9cab0674028f3fdfa06}{A\+Star\+Solve$<$ T $>$}} (this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ graph, T start, T end, \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator}{I\+Calculator}}$<$ T $>$ calculator=null)
\begin{DoxyCompactList}\small\item\em Get a path between two points in the graph using the A$\ast$ algorithm. If no path can be found, an empty list is returned. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result}{Path\+Finding\+Result}}$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ac6850e8e292b5b81d93d85978c633e96}{A\+Star\+Solve\+With\+Info$<$ T $>$}} (this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ g, T start, T end, \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator}{I\+Calculator}}$<$ T $>$ calculator=null)
\begin{DoxyCompactList}\small\item\em Get a path between two points in the graph using the A$\ast$ algorithm. A list of the visited nodes is also returned. If no path can be found, the Path\+Finding\+Result$<$\+T$>$ will be empty, but no members will be null. ~\newline
Path\+Finding\+Result$<$\+T$>$ will contain the found path, the nodes that were queued to be evaluated (in Path\+Finding\+Result$<$\+T$>$.\+Open\+Nodes) and the nodes that were finally evaluated (in Path\+Finding\+Result$<$\+T$>$.\+Closed\+Nodes) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_afcd10463f4a8e867ac293ceffb169f60}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_afcd10463f4a8e867ac293ceffb169f60}} 
static List$<$ T $>$ {\bfseries Dijkstra\+Solve$<$ T $>$} (this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ graph, T start, T end)
\item 
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_abdb23b5d31c817edaeec719691a89422}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_abdb23b5d31c817edaeec719691a89422}} 
static \mbox{\hyperlink{struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result}{Path\+Finding\+Result}}$<$ T $>$ {\bfseries Dijkstra\+Solve\+With\+Info$<$ T $>$} (this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ g, T start, T end)
\item 
static List$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ad6ca1e185f6b7b197319633e5704ff0f}{Iterative\+Bfs\+Solve$<$ T $>$}} (this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ graph, T start, T end)
\begin{DoxyCompactList}\small\item\em Use the iterative bfs algorithm to find a path between {\itshape start}  and {\itshape end} . \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result}{Path\+Finding\+Result}}$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ac5337626a09f0ead8553600d50ecfce2}{Iterative\+Bfs\+Solve\+With\+Info$<$ T $>$}} (this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ graph, T start, T end)
\begin{DoxyCompactList}\small\item\em Use iterative B\+FS to find a path between {\itshape start}  and {\itshape end} . This method will also return the visited nodes in the process. ~\newline
The returned Path\+Finding\+Result$<$\+T$>$ will contain the path (in Path\+Finding\+Result$<$\+T$>$.\+Path), and the visited nodes (in Path\+Finding\+Result$<$\+T$>$.\+Open\+Nodes). Path\+Finding\+Result$<$\+T$>$.\+Closed\+Nodes will be empty as that is not applicable here. \end{DoxyCompactList}\item 
static List$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a6e1d3fb0d8a4115a811794b761e09f8c}{Recursive\+Solve$<$ T $>$}} (this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ graph, T start, T end)
\begin{DoxyCompactList}\small\item\em Kind of the worst kind of pathfinding you can choose, ever. ~\newline
It will (eventually) return a path between start and end using a recursive algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa6ef850657425957da22c35dd288c3e5}{A\+Star\+Get\+Most\+Promising\+Node$<$ T $>$}} (Hash\+Set$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}$<$ T $>$$>$ open)
\begin{DoxyCompactList}\small\item\em Get the most promising node from the provided open list. It will search for the node with the lowest F value (\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node_a287d611297fcd9a4f9ede4b018ecbe21}{A\+Star\+Node$<$\+T$>$.\+Estimated\+Complete\+Path\+Length}}) \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a92c58d3551358817dae374f53dfd9cc2}{A\+Star\+Expand\+Node$<$ T $>$}} (\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}$<$ T $>$ node, T finish, I\+Enumerable$<$ T $>$ neighbors, I\+Collection$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}$<$ T $>$$>$ open, I\+Collection$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}$<$ T $>$$>$ closed, \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator}{I\+Calculator}}$<$ T $>$ calculator)
\begin{DoxyCompactList}\small\item\em Expand a node, which means add all the neighbors to the open list, initialize them with the correct values (if that hasn\textquotesingle{}t been done) and update them if necessary (a better path to them is found) \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa659843ef4c92031c5d2da97b63b2a1a}{Dijkstra\+Expand\+Node$<$ T $>$}} (\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}$<$ T $>$ node, Hash\+Set$<$ T $>$ neighbors, I\+Collection$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}$<$ T $>$$>$ open, I\+Collection$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}$<$ T $>$$>$ closed, \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator}{I\+Calculator}}$<$ T $>$ calculator)
\begin{DoxyCompactList}\small\item\em Expand a node, which basically means to check if any of the neighbors need their values changed (or initialized) and, if they aren\textquotesingle{}t already, the eligible neighbors will be added to the waiting list, waiting to be evaluated. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa90995367a09dc1b1fabed2dcf69a0bd}{Throw\+On\+Invalid\+Input$<$ T $>$}} (this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ g, T start, T end)
\begin{DoxyCompactList}\small\item\em Throw if one of the input parameters is not a valid start node. \end{DoxyCompactList}\item 
static List$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ad62ecdf8f72844e361b2a623215fb276}{Build\+Path$<$ T $>$}} (\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}$<$ T $>$ from, I\+Enumerable$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}$<$ T $>$$>$ known\+Nodes)
\item 
static List$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a2cf6ae8891261175c39e7ef8293b5783}{Build\+Recursive\+Reverse\+Path$<$ T $>$}} (\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}$<$ T $>$ from, I\+Read\+Only\+Dictionary$<$ T, \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}$<$ T $>$$>$ known\+Nodes)
\begin{DoxyCompactList}\small\item\em Recursively build a path from a node using a lookup of values from the node wrapper to the actual containing type. \end{DoxyCompactList}\item 
static List$<$ T $>$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a07d5da12d0957916d595a38770329d5f}{Recursive\+Solve$<$ T $>$}} (\mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$ graph, T start, T end, List$<$ T $>$ path\+To, int depth=0)
\begin{DoxyCompactList}\small\item\em The actual recursive method that is used to calculate the path. ~\newline
This method has an \char`\"{}artificial\char`\"{} recursion anchor at Max\+Depth to prevent a Stack\+Overflow\+Exception. It will simply stop recursing deeper after a depth higher than Max\+Depth. ~\newline
Use cautiously \+:) it can take a while. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a5d0d0fa3bb2d2c6203af17dd61eba219}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a5d0d0fa3bb2d2c6203af17dd61eba219}} 
const int {\bfseries Max\+Depth} = 100
\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a92c58d3551358817dae374f53dfd9cc2}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a92c58d3551358817dae374f53dfd9cc2}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!AStarExpandNode$<$ T $>$@{AStarExpandNode$<$ T $>$}}
\index{AStarExpandNode$<$ T $>$@{AStarExpandNode$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{AStarExpandNode$<$ T $>$()}{AStarExpandNode< T >()}}
{\footnotesize\ttfamily static void C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+A\+Star\+Expand\+Node$<$ T $>$ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}$<$ T $>$}]{node,  }\item[{T}]{finish,  }\item[{I\+Enumerable$<$ T $>$}]{neighbors,  }\item[{I\+Collection$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}$<$ T $>$$>$}]{open,  }\item[{I\+Collection$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}$<$ T $>$$>$}]{closed,  }\item[{\mbox{\hyperlink{interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator}{I\+Calculator}}$<$ T $>$}]{calculator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Expand a node, which means add all the neighbors to the open list, initialize them with the correct values (if that hasn\textquotesingle{}t been done) and update them if necessary (a better path to them is found) 


\begin{DoxyParams}{Parameters}
{\em node} & The node to expand\\
\hline
{\em finish} & The finish we strive for\\
\hline
{\em neighbors} & The neighbors of the passed node (to prevent passing the graph)\\
\hline
{\em open} & The list of nodes that might be expanded later\\
\hline
{\em closed} & The list of nodes we don\textquotesingle{}t want to expand later\\
\hline
{\em calculator} & The calculator we want to use to calculate distances between nodes\\
\hline
\end{DoxyParams}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa6ef850657425957da22c35dd288c3e5}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa6ef850657425957da22c35dd288c3e5}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!AStarGetMostPromisingNode$<$ T $>$@{AStarGetMostPromisingNode$<$ T $>$}}
\index{AStarGetMostPromisingNode$<$ T $>$@{AStarGetMostPromisingNode$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{AStarGetMostPromisingNode$<$ T $>$()}{AStarGetMostPromisingNode< T >()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+A\+Star\+Get\+Most\+Promising\+Node$<$ T $>$ (\begin{DoxyParamCaption}\item[{Hash\+Set$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node}{A\+Star\+Node}}$<$ T $>$$>$}]{open }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Get the most promising node from the provided open list. It will search for the node with the lowest F value (\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_a_star_node_a287d611297fcd9a4f9ede4b018ecbe21}{A\+Star\+Node$<$\+T$>$.\+Estimated\+Complete\+Path\+Length}}) 

\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a3719d88e07c2d9cab0674028f3fdfa06}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a3719d88e07c2d9cab0674028f3fdfa06}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!AStarSolve$<$ T $>$@{AStarSolve$<$ T $>$}}
\index{AStarSolve$<$ T $>$@{AStarSolve$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{AStarSolve$<$ T $>$()}{AStarSolve< T >()}}
{\footnotesize\ttfamily static List$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+A\+Star\+Solve$<$ T $>$ (\begin{DoxyParamCaption}\item[{this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$}]{graph,  }\item[{T}]{start,  }\item[{T}]{end,  }\item[{\mbox{\hyperlink{interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator}{I\+Calculator}}$<$ T $>$}]{calculator = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get a path between two points in the graph using the A$\ast$ algorithm. If no path can be found, an empty list is returned. 

\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ac6850e8e292b5b81d93d85978c633e96}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ac6850e8e292b5b81d93d85978c633e96}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!AStarSolveWithInfo$<$ T $>$@{AStarSolveWithInfo$<$ T $>$}}
\index{AStarSolveWithInfo$<$ T $>$@{AStarSolveWithInfo$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{AStarSolveWithInfo$<$ T $>$()}{AStarSolveWithInfo< T >()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result}{Path\+Finding\+Result}}$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+A\+Star\+Solve\+With\+Info$<$ T $>$ (\begin{DoxyParamCaption}\item[{this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$}]{g,  }\item[{T}]{start,  }\item[{T}]{end,  }\item[{\mbox{\hyperlink{interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator}{I\+Calculator}}$<$ T $>$}]{calculator = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get a path between two points in the graph using the A$\ast$ algorithm. A list of the visited nodes is also returned. If no path can be found, the Path\+Finding\+Result$<$\+T$>$ will be empty, but no members will be null. ~\newline
Path\+Finding\+Result$<$\+T$>$ will contain the found path, the nodes that were queued to be evaluated (in Path\+Finding\+Result$<$\+T$>$.\+Open\+Nodes) and the nodes that were finally evaluated (in Path\+Finding\+Result$<$\+T$>$.\+Closed\+Nodes) 

\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ad62ecdf8f72844e361b2a623215fb276}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ad62ecdf8f72844e361b2a623215fb276}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!BuildPath$<$ T $>$@{BuildPath$<$ T $>$}}
\index{BuildPath$<$ T $>$@{BuildPath$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{BuildPath$<$ T $>$()}{BuildPath< T >()}}
{\footnotesize\ttfamily static List$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+Build\+Path$<$ T $>$ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}$<$ T $>$}]{from,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}$<$ T $>$$>$}]{known\+Nodes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}





Build a path from a node (usually the finish node of the pathfinding request) and a collection of known nodes (which will be used as a look up into the graph). 

{\itshape from}  will be the last node in the built path, as this is the node to get the predecessor from. 


\begin{DoxyParams}{Parameters}
{\em from} & The node to build the recursively build the path from.\\
\hline
{\em known\+Nodes} & \\
\hline
\end{DoxyParams}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a2cf6ae8891261175c39e7ef8293b5783}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a2cf6ae8891261175c39e7ef8293b5783}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!BuildRecursiveReversePath$<$ T $>$@{BuildRecursiveReversePath$<$ T $>$}}
\index{BuildRecursiveReversePath$<$ T $>$@{BuildRecursiveReversePath$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{BuildRecursiveReversePath$<$ T $>$()}{BuildRecursiveReversePath< T >()}}
{\footnotesize\ttfamily static List$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+Build\+Recursive\+Reverse\+Path$<$ T $>$ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}$<$ T $>$}]{from,  }\item[{I\+Read\+Only\+Dictionary$<$ T, \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_node}{Node}}$<$ T $>$$>$}]{known\+Nodes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Recursively build a path from a node using a lookup of values from the node wrapper to the actual containing type. 


\begin{DoxyParams}{Parameters}
{\em from} & The node to build from\\
\hline
{\em known\+Nodes} & A look up from the node wrapper to the graph type\\
\hline
\end{DoxyParams}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa659843ef4c92031c5d2da97b63b2a1a}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa659843ef4c92031c5d2da97b63b2a1a}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!DijkstraExpandNode$<$ T $>$@{DijkstraExpandNode$<$ T $>$}}
\index{DijkstraExpandNode$<$ T $>$@{DijkstraExpandNode$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{DijkstraExpandNode$<$ T $>$()}{DijkstraExpandNode< T >()}}
{\footnotesize\ttfamily static void C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+Dijkstra\+Expand\+Node$<$ T $>$ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}$<$ T $>$}]{node,  }\item[{Hash\+Set$<$ T $>$}]{neighbors,  }\item[{I\+Collection$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}$<$ T $>$$>$}]{open,  }\item[{I\+Collection$<$ \mbox{\hyperlink{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_dijkstra_node}{Dijkstra\+Node}}$<$ T $>$$>$}]{closed,  }\item[{\mbox{\hyperlink{interface_c_m_g_t_graph_1_1_calculators_1_1_i_calculator}{I\+Calculator}}$<$ T $>$}]{calculator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Expand a node, which basically means to check if any of the neighbors need their values changed (or initialized) and, if they aren\textquotesingle{}t already, the eligible neighbors will be added to the waiting list, waiting to be evaluated. 


\begin{DoxyParams}{Parameters}
{\em node} & The node to check the neighbors of\\
\hline
{\em neighbors} & The neighbors of this node\\
\hline
{\em open} & The list of nodes that are already queued for evaluation\\
\hline
{\em closed} & The list of nodes that is finished with this shit\\
\hline
{\em calculator} & The calculator to use for distance calculation\\
\hline
\end{DoxyParams}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ad6ca1e185f6b7b197319633e5704ff0f}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ad6ca1e185f6b7b197319633e5704ff0f}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!IterativeBfsSolve$<$ T $>$@{IterativeBfsSolve$<$ T $>$}}
\index{IterativeBfsSolve$<$ T $>$@{IterativeBfsSolve$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{IterativeBfsSolve$<$ T $>$()}{IterativeBfsSolve< T >()}}
{\footnotesize\ttfamily static List$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+Iterative\+Bfs\+Solve$<$ T $>$ (\begin{DoxyParamCaption}\item[{this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$}]{graph,  }\item[{T}]{start,  }\item[{T}]{end }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Use the iterative bfs algorithm to find a path between {\itshape start}  and {\itshape end} . 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph to solve on\\
\hline
{\em start} & The start node\\
\hline
{\em end} & The end node\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Graph$<$\+T$>$.\+Node\+Not\+Found\+Exception} & This will be thrown if either start or end are in the graph.\\
\hline
{\em Invalid\+Operation\+Exception} & This will be thrown when one of the nodes is not passable at the time of asking (politely of course)\\
\hline
\end{DoxyExceptions}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ac5337626a09f0ead8553600d50ecfce2}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_ac5337626a09f0ead8553600d50ecfce2}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!IterativeBfsSolveWithInfo$<$ T $>$@{IterativeBfsSolveWithInfo$<$ T $>$}}
\index{IterativeBfsSolveWithInfo$<$ T $>$@{IterativeBfsSolveWithInfo$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{IterativeBfsSolveWithInfo$<$ T $>$()}{IterativeBfsSolveWithInfo< T >()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_1_1_path_finding_result}{Path\+Finding\+Result}}$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+Iterative\+Bfs\+Solve\+With\+Info$<$ T $>$ (\begin{DoxyParamCaption}\item[{this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$}]{graph,  }\item[{T}]{start,  }\item[{T}]{end }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Use iterative B\+FS to find a path between {\itshape start}  and {\itshape end} . This method will also return the visited nodes in the process. ~\newline
The returned Path\+Finding\+Result$<$\+T$>$ will contain the path (in Path\+Finding\+Result$<$\+T$>$.\+Path), and the visited nodes (in Path\+Finding\+Result$<$\+T$>$.\+Open\+Nodes). Path\+Finding\+Result$<$\+T$>$.\+Closed\+Nodes will be empty as that is not applicable here. 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph to operate on\\
\hline
{\em start} & The node to start searching from\\
\hline
{\em end} & The node that is the finish\\
\hline
\end{DoxyParams}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a07d5da12d0957916d595a38770329d5f}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a07d5da12d0957916d595a38770329d5f}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!RecursiveSolve$<$ T $>$@{RecursiveSolve$<$ T $>$}}
\index{RecursiveSolve$<$ T $>$@{RecursiveSolve$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{RecursiveSolve$<$ T $>$()}{RecursiveSolve< T >()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static List$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+Recursive\+Solve$<$ T $>$ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$}]{graph,  }\item[{T}]{start,  }\item[{T}]{end,  }\item[{List$<$ T $>$}]{path\+To,  }\item[{int}]{depth = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



The actual recursive method that is used to calculate the path. ~\newline
This method has an \char`\"{}artificial\char`\"{} recursion anchor at Max\+Depth to prevent a Stack\+Overflow\+Exception. It will simply stop recursing deeper after a depth higher than Max\+Depth. ~\newline
Use cautiously \+:) it can take a while. 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph to perform the operation on.\\
\hline
{\em start} & The start node of the problem\\
\hline
{\em end} & The end node.\\
\hline
{\em path\+To} & The current path to the start node.\\
\hline
{\em depth} & The current depth we are at.\\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T} & \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
Returns the reverse path from start to end
\end{DoxyReturn}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a6e1d3fb0d8a4115a811794b761e09f8c}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_a6e1d3fb0d8a4115a811794b761e09f8c}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!RecursiveSolve$<$ T $>$@{RecursiveSolve$<$ T $>$}}
\index{RecursiveSolve$<$ T $>$@{RecursiveSolve$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{RecursiveSolve$<$ T $>$()}{RecursiveSolve< T >()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static List$<$T$>$ C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+Recursive\+Solve$<$ T $>$ (\begin{DoxyParamCaption}\item[{this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$}]{graph,  }\item[{T}]{start,  }\item[{T}]{end }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Kind of the worst kind of pathfinding you can choose, ever. ~\newline
It will (eventually) return a path between start and end using a recursive algorithm. 

\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa90995367a09dc1b1fabed2dcf69a0bd}\label{class_c_m_g_t_graph_1_1_algorithms_1_1_algorithms_aa90995367a09dc1b1fabed2dcf69a0bd}} 
\index{CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}!ThrowOnInvalidInput$<$ T $>$@{ThrowOnInvalidInput$<$ T $>$}}
\index{ThrowOnInvalidInput$<$ T $>$@{ThrowOnInvalidInput$<$ T $>$}!CMGTGraph.Algorithms.Algorithms@{CMGTGraph.Algorithms.Algorithms}}
\doxysubsubsection{\texorpdfstring{ThrowOnInvalidInput$<$ T $>$()}{ThrowOnInvalidInput< T >()}}
{\footnotesize\ttfamily static void C\+M\+G\+T\+Graph.\+Algorithms.\+Algorithms.\+Throw\+On\+Invalid\+Input$<$ T $>$ (\begin{DoxyParamCaption}\item[{this \mbox{\hyperlink{interface_c_m_g_t_graph_1_1_i_read_only_graph}{I\+Read\+Only\+Graph}}$<$ T $>$}]{g,  }\item[{T}]{start,  }\item[{T}]{end }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Throw if one of the input parameters is not a valid start node. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyExceptions}{Exceptions}
{\em Graph$<$\+T$>$.\+Node\+Not\+Found\+Exception} & \\
\hline
{\em Invalid\+Operation\+Exception} & \\
\hline
\end{DoxyExceptions}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em I\+Equatable$<$T$>$}]\end{description}
\end{Desc}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+M\+G\+T\+Graph/\+Algorithms/Algorithms-\/\+A\+Star.\+cs\item 
C\+M\+G\+T\+Graph/\+Algorithms/Algorithms-\/\+Recursive\+Path.\+cs\item 
C\+M\+G\+T\+Graph/\+Algorithms/Algorithms-\/\+Dijkstra.\+cs\item 
C\+M\+G\+T\+Graph/\+Algorithms/Algorithms-\/\+Helpers.\+cs\item 
C\+M\+G\+T\+Graph/\+Algorithms/Algorithms-\/\+Iterative\+B\+F\+S.\+cs\end{DoxyCompactItemize}
